<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>AlphaAgents Debate</title>
    <link rel="stylesheet" href="/static/css/style.css" />
  </head>
  <body>
    <main class="container">
      <section class="hero">
        <h1>AlphaAgents Prototype</h1>
        <p>Enter a ticker to trigger a debate among the domain agents.</p>
        <form id="run-form" class="run-form">
          <label>
            Ticker
            <input id="ticker-input" name="ticker" value="AAPL" />
          </label>
          <label>
            Risk Profile
            <select id="risk-input" name="risk_profile">
              <option value="risk_neutral" selected>Risk Neutral</option>
              <option value="risk_averse">Risk Averse</option>
            </select>
          </label>
          <button type="submit">Start Session</button>
        </form>
        <p class="mock-note">Currently uses structured mock context for AAPL, MSFT, and TSLA.</p>
      </section>

      <section class="debate-panel">
        <header>
          <h2>Live Debate Stream</h2>
          <span id="status" class="status status-idle">Idle</span>
        </header>
        <ul id="debate-log" class="debate-log"></ul>
      </section>

      <section class="trace-panel">
        <header>
          <h2>Coordinator Insights</h2>
          <div class="trace-actions">
            <button id="toggle-explanation" disabled>Show Explanation</button>
            <button id="toggle-trace" disabled>Show Reasoning Trace</button>
            <span id="consensus-decision" class="trace-decision"></span>
          </div>
        </header>
        <div id="explanation-panel" class="trace-content hidden">
          <h3>LLM Summary</h3>
          <p id="consensus-explanation" class="trace-placeholder">Run a session to generate the LLM narrative.</p>
          <h4>Key Points</h4>
          <ul id="consensus-points" class="trace-points"></ul>
        </div>
        <div id="reasoning-trace" class="trace-content hidden">
          <h3>Reasoning Trace</h3>
          <ul id="trace-log"></ul>
        </div>
      </section>

      <section class="plots-panel">
        <header>
          <h2>Backtest Metrics</h2>
          <div id="backtest-summary" class="backtest-summary"></div>
        </header>
        <div id="plots-placeholder" class="plots-placeholder">Start a session to generate performance charts.</div>
        <div class="plots-grid hidden" id="plots-grid">
          <figure>
            <img id="plot-cumulative" src="" alt="Cumulative Return plot" />
            <figcaption>Cumulative Return</figcaption>
          </figure>
          <figure>
            <img id="plot-sharpe" src="" alt="Rolling Sharpe plot" />
            <figcaption>Rolling Sharpe</figcaption>
          </figure>
          <figure>
            <img id="plot-drawdown" src="" alt="Drawdown plot" />
            <figcaption>Drawdown Profile</figcaption>
          </figure>
        </div>
      </section>
    </main>

    <script>
      (function () {
        const form = document.getElementById("run-form");
        const tickerInput = document.getElementById("ticker-input");
        const riskInput = document.getElementById("risk-input");
        const log = document.getElementById("debate-log");
        const submitButton = form.querySelector("button[type='submit']");
        const statusBadge = document.getElementById("status");
        const consensusDecision = document.getElementById("consensus-decision");
        const toggleExplanationButton = document.getElementById("toggle-explanation");
        const toggleTraceButton = document.getElementById("toggle-trace");
        const consensusExplanationEl = document.getElementById("consensus-explanation");
        const consensusPointsEl = document.getElementById("consensus-points");
        const explanationPanel = document.getElementById("explanation-panel");
        const tracePanel = document.getElementById("reasoning-trace");
        const traceLogEl = document.getElementById("trace-log");
        const plotCumulative = document.getElementById("plot-cumulative");
        const plotSharpe = document.getElementById("plot-sharpe");
        const plotDrawdown = document.getElementById("plot-drawdown");
        const plotsPlaceholder = document.getElementById("plots-placeholder");
        const plotsGrid = document.getElementById("plots-grid");
        const backtestSummary = document.getElementById("backtest-summary");

        const defaultButtonLabel = submitButton ? submitButton.textContent : "Start Session";
        let inFlight = false;
        let explanationVisible = false;
        let traceVisible = false;
        let debateTimer = null;

        function setStatus(text, state) {
          statusBadge.textContent = text;
          statusBadge.className = `status status-${state}`;
        }

        function resetInterface() {
          if (debateTimer) {
            clearTimeout(debateTimer);
            debateTimer = null;
          }
          setStatus("Idle", "idle");
          log.innerHTML = "";
          consensusDecision.textContent = "";
          consensusExplanationEl.textContent = "Run a session to generate the LLM narrative.";
          consensusPointsEl.innerHTML = "";
          explanationPanel.classList.add("hidden");
          tracePanel.classList.add("hidden");
          explanationVisible = false;
          traceVisible = false;
          toggleExplanationButton.disabled = true;
          toggleTraceButton.disabled = true;
          toggleExplanationButton.textContent = "Show Explanation";
          toggleTraceButton.textContent = "Show Reasoning Trace";
          traceLogEl.innerHTML = "";
          plotsPlaceholder.classList.remove("hidden");
          plotsGrid.classList.add("hidden");
          plotCumulative.removeAttribute("src");
          plotSharpe.removeAttribute("src");
          plotDrawdown.removeAttribute("src");
          backtestSummary.innerHTML = "";
        }

        function formatContent(text = "") {
          if (!text) return "";
          if (text.startsWith("[LLM:")) {
            return text;
          }

          const escaped = text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");

          const bulletItems = escaped
            .split(/\n+/)
            .map((line) => line.trim())
            .filter((line) => line.startsWith("- "));
          if (bulletItems.length) {
            const lis = bulletItems
              .map((line) => line.replace(/^[-]+\s*/, ""))
              .map((item) => `<li>${item}</li>`)
              .join("");
            return `<ul>${lis}</ul>`;
          }

          const normalized = escaped.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
          const paragraphs = normalized
            .split(/\n{2,}/)
            .map((block) => block.replace(/\n/g, "<br>"));
          return `<p>${paragraphs.join("</p><p>")}</p>`;
        }

        function appendMessage(message) {
          const fallback = message.content?.startsWith?.("[LLM:");
          const li = document.createElement("li");
          li.className = `debate-entry debate-${message.agent}${fallback ? " fallback" : ""}`;
          li.innerHTML = `
            <span class="meta">Round ${message.round} · ${message.agent} · ${message.stage}</span>
            <span class="content">${formatContent(message.content)}</span>
          `;
          log.appendChild(li);
          li.scrollIntoView({ behavior: "smooth", block: "end" });
        }

        function playDebate(messages = []) {
          if (!messages.length) {
            setStatus("Debate Complete", "idle");
            return;
          }

          let index = 0;
          const displayNext = () => {
            appendMessage(messages[index]);
            index += 1;
            if (index < messages.length) {
              debateTimer = setTimeout(displayNext, 550);
            } else {
              setStatus("Debate Complete", "idle");
            }
          };
          setStatus("Debate in progress…", "active");
          displayNext();
        }

        function updateConsensus(consensus) {
          if (!consensus) {
            consensusDecision.textContent = "Decision unavailable.";
            return;
          }

          consensusDecision.textContent = `Decision: ${consensus.final_decision} (Conviction ${consensus.conviction})`;
          const fallbackFlag = consensus.metrics?.llm_explanation_fallback ?? 0;
          const points = consensus.explanation_points || [];

          if (!consensus.explanation_llm || fallbackFlag) {
            consensusExplanationEl.textContent = "LLM explanation unavailable (fallback response).";
          } else {
            consensusExplanationEl.innerHTML = formatContent(consensus.explanation_llm);
          }

          consensusPointsEl.innerHTML = "";
          if (!fallbackFlag && points.length) {
            points.forEach((point) => {
              const li = document.createElement("li");
              li.textContent = point;
              consensusPointsEl.appendChild(li);
            });
          }
        }

        function updateBacktest(backtest) {
          if (!backtest) {
            backtestSummary.innerHTML = "<div>No backtest results.</div>";
            return;
          }

          const { sharpe, max_drawdown, final_return, plots } = backtest;
          backtestSummary.innerHTML = `
            <div>Sharpe: ${sharpe ?? "N/A"}</div>
            <div>Max Drawdown: ${max_drawdown ?? "N/A"}</div>
            <div>Final Return: ${final_return ?? "N/A"}</div>
          `;

          if (plots) {
            const cacheBuster = `?t=${Date.now()}`;
            if (plots.cumulative) {
              plotCumulative.src = `${plots.cumulative}${cacheBuster}`;
            }
            if (plots.rolling_sharpe) {
              plotSharpe.src = `${plots.rolling_sharpe}${cacheBuster}`;
            }
            if (plots.drawdown) {
              plotDrawdown.src = `${plots.drawdown}${cacheBuster}`;
            }
            plotsPlaceholder.classList.add("hidden");
            plotsGrid.classList.remove("hidden");
          } else {
            plotsPlaceholder.classList.remove("hidden");
            plotsGrid.classList.add("hidden");
          }
        }

        function renderTrace(entries) {
          traceLogEl.innerHTML = "";

          if (!entries.length) {
            const li = document.createElement("li");
            li.className = "trace-placeholder";
            li.textContent = "No reasoning trace available yet.";
            traceLogEl.appendChild(li);
            return;
          }

          entries.forEach((entry) => {
            const confidence = entry.result?.confidence ?? entry.result?.score ?? "N/A";
            const fallback = entry.result?.fallback;
            const li = document.createElement("li");
            li.innerHTML = `
              <details>
                <summary>${entry.agent_role} · ${entry.stage} · score: ${confidence}${fallback ? " (fallback)" : ""}</summary>
                <pre class="trace-json">Variables:
${JSON.stringify(entry.variables, null, 2)}
</pre>
                <pre class="trace-json">Result:
${JSON.stringify(entry.result, null, 2)}
</pre>
              </details>
            `;
            traceLogEl.appendChild(li);
          });
        }

        async function fetchReasoningTrace(sessionId) {
          try {
            const response = await fetch(`/api/trace/${sessionId}`);
            if (!response.ok) {
              throw new Error("Failed to load trace");
            }
            const data = await response.json();
            renderTrace(data.entries || []);
            toggleTraceButton.disabled = false;
          } catch (error) {
            console.error(error);
          }
        }

        toggleExplanationButton.addEventListener("click", () => {
          explanationVisible = !explanationVisible;
          explanationPanel.classList.toggle("hidden", !explanationVisible);
          toggleExplanationButton.textContent = explanationVisible ? "Hide Explanation" : "Show Explanation";
        });

        toggleTraceButton.addEventListener("click", () => {
          traceVisible = !traceVisible;
          tracePanel.classList.toggle("hidden", !traceVisible);
          toggleTraceButton.textContent = traceVisible ? "Hide Trace" : "Show Reasoning Trace";
        });

        form.addEventListener("submit", async (event) => {
          event.preventDefault();
          if (inFlight) {
            return;
          }
          inFlight = true;
          if (submitButton) {
            submitButton.disabled = true;
            submitButton.textContent = "Running…";
          }
          resetInterface();

          const ticker = tickerInput.value.trim() || "AAPL";
          const riskProfile = riskInput.value;
          setStatus("Analysing…", "loading");

          try {
            const response = await fetch("/run_ticker", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ ticker, risk_profile: riskProfile }),
            });
            if (!response.ok) {
              const message =
                response.status === 429
                  ? "Another session is already running. Please wait."
                  : "Failed to start session";
              throw new Error(message);
            }

            const data = await response.json();
            const { consensus, backtest, session_id, debate = [] } = data;

            updateConsensus(consensus);
            updateBacktest(backtest);
            toggleExplanationButton.disabled = false;
            playDebate(debate);
            fetchReasoningTrace(session_id);
          } catch (error) {
            setStatus("Error", "error");
            console.error(error);
            consensusDecision.textContent = error?.message ?? "Request failed.";
          } finally {
            inFlight = false;
            if (submitButton) {
              submitButton.disabled = false;
              submitButton.textContent = defaultButtonLabel;
            }
          }
        });
      })();
    </script>
  </body>
</html>
